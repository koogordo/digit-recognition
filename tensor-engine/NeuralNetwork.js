const MnistDataSet = require('./MnistDataSet');
const tf = require('@tensorflow/tfjs');
class NeuralNetwork {
  constructor() {
    this.mds = new MnistDataSet();
  }

  createModel() {
    //create a sequential model where layers can be stacked
    this.model = tf.sequential();
    const LEARNING_RATE = 0.15;
    //takes in config objects
    this.model.add(
      tf.layers.conv2d({
        inputShape: [28, 28, 1],
        kernelSize: 5, //The size of the sliding convolutional filter windows to be applied to the input data. 5x5 pixels
        filters: 8, //nThe number of filter windows to apply to the input data
        strides: 1, //how many pixels the filter will shift each time it moves over the image.
        activation: 'relu',
        kernelInitializer: 'VarianceScaling' //The method to use for randomly initializing the model weights, which is very important to training dynamics
      })
    );
    //max pooling downsamples it
    this.model.add(
      tf.layers.maxPooling2d({
        poolSize: [2, 2], //The size of the sliding pooling windows to be applied to the input data.
        strides: [2, 2] //means that the pooling layer will apply 2x2 windows to the input data.
      })
    );
    //we repeat the 2 layers increasing the filters from 8 to 16
    this.model.add(
      tf.layers.conv2d({
        //input shape 'inherited' from last conv2d layer
        kernelSize: 5,
        filters: 16,
        strides: 1,
        activation: 'relu',
        kernelInitializer: 'VarianceScaling'
      })
    );
    this.model.add(
      tf.layers.maxPooling2d({
        poolSize: [2, 2],
        strides: [2, 2]
      })
    );

    //Next, let's add a flatten layer to flatten the output of the previous layer to a vector
    this.model.add(tf.layers.flatten());

    //add a dense layer (also known as a fully connected layer), which will perform the final classification.
    this.model.add(
      tf.layers.dense({
        units: 10,
        kernelInitializer: 'VarianceScaling',
        activation: 'softmax' //create probability distribution for all output options
      })
    );

    console.log('Model Created :)');
    this.model.save(`file:///${__dirname}/../public/digit-recog-model`);
    console.log('Model Saved!');
    /*
    categoricalCrossentropy:
    measures the error between the probability distribution generated by the last layer 
    of our model and the probability distribution given by our label, 
    which will be a distribution with 1 (100%) in the correct class label.
    */
  }

  async train() {
    const BATCH_SIZE = 64;
    const TRAIN_BATCHES = 100;
    const EPOCHS = 1;
    const TEST_BATCH_SIZE = 1000;
    const TEST_ITERATION_FREQUENCY = 5;
    let shuffledBatches = this.shuffle(this.batchObjects);
    let inputs = [];
    let outputs = [];
    console.log('Loading model');

    console.log('Done Loading');
    console.log('Creating inputs...');
    for (let i = 0; i < shuffledBatches.length; i++) {
      let xs = tf.tensor4d(shuffledBatches[i].xs, [64, 28, 28, 1]);
      inputs.push(xs);
      let ys = tf.tensor2d(shuffledBatches[i].ys, [64, 10]);
      outputs.push(ys);
    }
    console.log('Inputs done being created...');

    let start = Date.now();
    for (let i = 0; i < TRAIN_BATCHES; i++) {
      await this.model
        .fit(inputs[i], outputs[i], {
          epochs: EPOCHS,
          batchSize: BATCH_SIZE
        })
        .then(history => history)
        .catch(err => console.log(err));
    }
    console.log(`First round of training took: ${start - Date.now() / 1000}ms`);
  }

  shuffle(batches) {
    console.log('Shuffling beginning...');
    let counter = batches.length;

    // While there are elements in the array
    while (counter > 0) {
      // Pick a random index
      let index = Math.floor(Math.random() * counter);

      // Decrease counter by 1
      counter--;

      // And swap the last element with it
      let temp = batches[counter];
      batches[counter] = batches[index];
      batches[index] = temp;
    }
    return batches;
  }

  async beginTraining() {
    this.mds
      .loadDataBuffer()
      .then(dfb => {
        this.mds
          .loadLabelBuffer()
          .then(lfb => {
            this.mds
              .toBatchObjects(dfb, lfb)
              .then(batchObjs => {
                this.batchObjects = batchObjs;
                //this.createModel(this.batchObjects);
                //this.createModel().then(() => {
                (async () => {
                  const LEARNING_RATE = 0.15;
                  this.model = await tf.loadModel(
                    `file:///${__dirname}/../public/digit-recog-model/model.json`
                  );
                  await this.model.compile({
                    optimizer: tf.train.sgd(LEARNING_RATE), //
                    loss: 'categoricalCrossentropy',
                    metrics: ['accuracy']
                  });
                  for (let i = 0; i < 100; i++) {
                    console.log(`Starting epoch ${i + 1}...`);
                    await this.train();
                    console.log(`Finishing epoch ${i + 1}...`);
                  }
                  this.model.save(
                    `file:///${__dirname}/../public/digit-recog-model`
                  );
                  console.log('Model saved!');
                })();
                //});
              })
              .catch(err => console.log(err));
          })
          .catch(err => console.log(err));
      })
      .catch(err => console.log(err));
  }

  predict() {
    this.mds
      .loadDataBuffer()
      .then(dfb => {
        this.mds
          .loadLabelBuffer()
          .then(lfb => {
            this.mds
              .toBatchObjects(dfb, lfb)
              .then(batchObjs => {
                this.batchObjects = this.shuffle(batchObjs);
                (async () => {
                  console.log('Loading model');
                  const model = await tf.loadModel(
                    `file:///${__dirname}/../public/digit-recog-model/model.json`
                  );
                  console.log('Done Loading');
                  let toPredict = this.batchObjects[
                    Math.floor(Math.random() * (500 - 0) + 0)
                  ];
                  let xsPad = [];
                  xsPad = Array.apply(null, Array(49392)).map(
                    Number.prototype.valueOf,
                    0
                  );
                  let xsReal = toPredict.xs.splice(0, 784);
                  let joinedPredict = xsReal.concat(xsPad);
                  let xs = tf.tensor4d(joinedPredict, [64, 28, 28, 1]);
                  console.log(
                    `The correct label is: [${toPredict.ys[0]},${
                      toPredict.ys[1]
                    },${toPredict.ys[2]},${toPredict.ys[3]},${
                      toPredict.ys[4]
                    },${toPredict.ys[5]},${toPredict.ys[6]},${
                      toPredict.ys[7]
                    },${toPredict.ys[8]},${toPredict.ys[9]}]`
                  );
                  console.log(model.predict(xs).print());
                })();
              })
              .catch(err => console.log(err));
          })
          .catch(err => console.log(err));
      })
      .catch(err => console.log(err));
  }
}

module.exports = NeuralNetwork;
